# Митраков Лев ИТ-2 Лабораторная №3

# Задание 1

## Задача 4
### Текст задачи
Дроби.
Измените сущность Дробь из задачи 1.5.5. Реализуйте следующие требования:
• Дробь не может быть изменена после создания
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель
не может быть отрицательным.
Продемонстрируйте работоспособность решения на примерах.
### Алгоритм решения
1. Берём файл класса Дроби из прошлой лабораторной работы.
2. Делаем числитель и знаменатель не изменяемыми с помощью ```final```.
3. Изменяем, что при создании дроби, если знаменатель отрицательный, то умножноем числитель и знаменатель на -1.

## Задача 7
### Текст задачи
Непустые Имена.
Измените сущность Имя из задачи 1.4.5. Гарантируйте, что:
• Как минимум один параметр будет иметь не null значение и не пустую строку.
• Имя неизменяемо.
Продемонстрируйте работоспособность решения на примерах.
### Алгоритм решения
1. Берём файл класса Имени из прошлой лабораторной.
2. Делаем проверку, что при создании класса, у нас хотя бы одно полен не пустой и не null.
3. Делаем поля класса неизменяемыми с помощью ```final```.

# Задание 2
## Задача 2
### Текст задачи
Секреты.
Секреты никому нельзя рассказывать. Никому кроме одного самого близкого друга! Необходимо
описать сущность Секрет, которая будет позволять хранить и передавать некоторый текст только
одному другому хранителю.
Состояние сущности описывают следующие сведения:
• Текст секрета, в виде строки.
• Имя хранителя секрета, в виде строки
Инициализация сущности может быть выполнена следующим образом:
• С указанием имени хранителя секрета и текста секрета, это будет означать создание
нового секрета.
• С указанием другого Секрета и именем хранителя секрета. В этом случае мы считаем, что
секрет был рассказан другому человеку. При передаче секрета должно произойти
следующее: во-первых, на консоль выводится текст вида “Имя сказал что Секрет”, где Имя
и Секрет представляют собой имя того кто рассказывает секрет и текст секрета
соответственно. Во-вторых, текст секрета у нового хранителя должен представлять собой
копию текста предыдущего хранителя, но с добавлением Х случайных символов в Х
случайных мест, где Х — это число в диапазоне от 0 до N, а Nв свою очередь это 10% от
размера исходного текста.
Поведение сущности описывают следующие действия:
• Может быть приведен к строке, строковое преставление вида“Имя: это секрет!”, где Имя –
это конкретное имя хранителя секрета, а остальное простой текст.
• Можно узнать каким по очереди был данных хранитель секрета.
• Можно узнать сколько еще человек узнали секрет после текущего хранителя
• Можно получить имя N-го человек узнавшего секрет, причем N будет положительным для
случая, когда мы хотим узнать имя следующего узнавшего секрет, и отрицательным если
предыдущего.
• Можно узнать разницу в количестве символов текста секрета с N-ым человеком
Необходимо учесть следующие требования к инкапсуляции:
• Единственным способом получить текст секрета может быт его вывод на экран при
инициализации объекта.
• Секрет может быть передан только одному другому человеку и не должно быть способа
рассказать один и тот же секрет нескольким людям.
Продемонстрируйте работоспособность решения на примерах.
### Алгоритм решения
1. Создаём класс Секрета с полями текст, владелец, предыдущий и следующий.
2. Создаём два конструктора где в первом аргрументы владелец и текст, а во втором секрет и владелец.
3. При использовании второго конструктора текст засоряется с помощью функции засорения, где добавляется случайные символы на случайные позиции в количестве 1/10 от длины текста наследуемого секрета.
4. Чтобы узнавать в какой позиции находится владелец, какой владелец у n позиции, сколько уже знает или уже после узнали секрет, используем поля предыдущий и следующий, как в двусвязном списке для хождения по секретам и подсчёта.
5. Чтобы узнать разницу мы берём длины текстов секретов n владельца и текущего. Находим их разницу под модулем и возвращаем.
6. Если поле следующий не является null, то мы запрещаем наследование секрета.

# Задание 3
## Задача 1
### Текст задачи
Запретная Дробь.
Измените сущность Дробь, полученную в задаче 2.1.4. Гарантируйте, что невозможно создать
такой подвид дроби, который позволял бы создавать Дроби с изменяемым состоянием.
### Алгоритм решение
1. Берём класс Дроби из задания 1 задачи 4 текущей лабораторной.
2. Дроби уже являются не изменяемыми и создают только такие дроби, которые не изменяются.

# Задание 4
## Задача 2
### Текст задачи
Дробь это число.
Измените сущность Дробь, полученную в задаче 2.3.1. Дробь должна быть подтипом класса
Number. Данный класс входит в стандартную редакцию языка Java.
### Алгоритм решения
1. Берём класс Дроби из задания 3 задачи 1 теущей лаборатоной.
2. Теперь делаем так, что класс Дроби теперь наследует класс ```Number```. ```public class Fraction extends Number {}```.

# Задание 5
## Задача 1
### Текст задачи
Сложение.
Разработайте метод, который принимает набор числовых значенийи возвращает их сумму в
вещественной форме. С использованием данного метода выполните следующие сложения:
• 2 + 3/5 + 2.3
• 3.6 + 49/12 + 3 + 3/2
• 1/3 + 1
### Алгоритм решения
1. Создаём класс Сумматора, который будет складывать любый числа наследующиеся от ```Number```.
2. В классе сумматора создаём статичный метод ```sum```, который принимает любое количество аргументов.
3. Метод преобразует число в **double** и складывает в результат. После возвращает значение в **double**.
4. Вставляем значения из примеров и выводим полученные результаты.

# Задание 6
## Задача 1
### Текст задачи
Сравнение дробей.
Измените сущность Дробь из задачи 2.4.2. Переопределите метод сравнения объектов по
состоянию таким образом, чтобы две дроби считались одинаковыми тогда, когда у них
одинаковые значения числителя и знаменателя.
### Алгоритм решения
1. Берём класс Дроби из задания 4 задачи 2 текущей лабораторной.
2. Добавление переобределение метода ```equals()```.
3. В методе делаем сравнение числителей и знаменателей. Если они равны, то возравщаем ```true```, иначе ```false```.

# Задание 7

## Задача 1
### Текст задачи
Навести порядок.
Данная задача предполагает реорганизацию ранее написанных классов. Расположите все ранее
написанные классы по пакетам таким образом, чтобы логически близкие классы оказались
сгруппированы друг с другом. Имена пакетов должны иметь как минимум трехсоставную форму,
вида: ru.surname.type. Вместо surname следует подставить свою фамилию, а вместо type
подставить название логического блока. Например, классы описывающие точку, линию, ломаную
линию, фигуру, квадрат, треугольник, круг и прямоугольник можно расположить в пакете
ru.surname.geometry.
### Алгоритм решения
1. Создаём директорию **ru**.
2. Внутри директории **ru**, создаём директорию **mitrakov**.
3. Внутри директории **ru/mitrakov/**, создаём директории:
- **fraction** (файлы класса Дроби)
- **name** (файлы класса Имени)
- **secret** (файлы класса Секрета)
- **summator** (файлы класса Сумматора)
4. В созданные директории распределяем файлы проекта и после в них указываем, что это пакеты пути в котором они находятся.

## Задача 2
### Текст задачи
Навести порядок.
Данная задача предполагает реорганизацию ранее написанных классов. Расположите все ранее
написанные классы по пакетам таким образом, чтобы логически близкие классы оказались
сгруппированы друг с другом. Имена пакетов должны иметь как минимум трехсоставную форму,
вида: ru.surname.type. Вместо surname следует подставить свою фамилию, а вместо type
подставить название логического блока. Например, классы описывающие точку, линию, ломаную
линию, фигуру, квадрат, треугольник, круг и прямоугольник можно расположить в пакете
ru.surname.geometry.
### Алгоритм решения
1. Создаём директорию **/ru/mitrakov/main** и помещаем туда **Main.java**.
2. Проверяем все пакеты на вхождение и оставляем только в пакете **ru.mitrakov.main**.
3. Размещаем задачу из задания 5 с вводом для пользователя.

# Задание 8
## Задача 3
### Текст задачи
Клонирование дроби.
Измените сущность Дробь из 2.6.1. Переопределите метод клонирования, унаследованный от
класса Object, таким образом, чтобы при его вызове возвращался новый объект Дроби, значения
полей которого будут копиями оригинальной Дроби.
### Алгоритм решения
1. Берём класс Дроби из задания 6 задачи 1 текущей лабораторной.
2. Добавляем что теперь класс Дроби имплементирует **Cloneable**. ```public class Fraction extends number implements Cloneable {}```.
3. Переопределяем метод ```clone()```, где возвращем новую Дробь с тем же числителем и знаменателем.
